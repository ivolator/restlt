{"name":"RestLt","tagline":"REST done easy with PHP","body":"##A \"thin\" REST-full server implementation in PHP \r\nRestLt is a flexible small library that will allow you to build RESTfull service.\r\nMost of the sub-components are extensible or replaceable. This would let you modify the server's behavior.\r\nAny feedback is appreciated!\r\n\r\n\r\n[![Build Status](https://travis-ci.org/ivolator/restlt.png)](https://travis-ci.org/ivolator/restlt)\r\n##Installing\r\n###Using Composer\r\nIn require section of your composer.json file add the information for RestLt as follows:\r\n```\r\n{ \r\n        \"require\" :\r\n        { \r\n                \"restlt/restlt\":\"1.0.0b\"\r\n        }\r\n}\r\n```\r\nRun `composer.phar --dev update`\r\n\r\n###Clone with GIT\r\nUse this URL to clone the repo\r\n`https://github.com/ivolator/restlt.git`\r\n\r\n##Basics \r\n###Server end point setup\r\n```php\r\n//Get instance of the server by passing the server base url\r\n$s = new Server ( '/' );\r\n//Tell the server where to find the resources\r\n$s->registerResourceFolder ( SOME_APPLICATION_ROOT .  '/resources', 'name\\space\\resources' );\r\n$s->registerResourceClass('example\\name\\space\\Resource');\r\necho $s->serve ();\r\nexit;\r\n``` \r\nIn your base server directory add an .htaccess file with the follwing content\r\n```\r\n<IfModule mod_rewrite.c>\r\n    RewriteEngine On\r\n    RewriteCond %{REQUEST_FILENAME} !-d\r\n    RewriteCond %{REQUEST_FILENAME} !-f\r\n    RewriteRule ^(.*)$ index.php?_url=/$1 [QSA,L]\r\n</IfModule>\r\n```\r\nNow you have bootstraped RestLt.\r\n\r\n###Creating a resource\r\n \r\n A resource in Rest Lite is a class that extends the \\restlt\\Resource class.\r\n Each resource can contain methods that respond to multiple GETs, POSTs, PUTs, DELETEs and PATCHs.\r\n It is important to mention that when you are registering resources with the server you are either registering a resource folder and providing a namespace or a single resource by providing the FQNS to resource class. Providing a FQNS (fully qualified name space) is necessary.\r\n \r\n To configure the URI for the resource, you need to setup couple of things.\r\n All the metadata is configurable via the PHP doc blocks. Examples are shown later.\r\n \r\n 1. Add the @resourceBaseUri in the class doc block.This will set up the base URI for all methods that will be contained in this resource\r\n    '@resourceBaseUri /user' - note the forward slash at the begining\r\n 2. Add @method to the doc block of the class method. This will tell the server what HTTP method this function will be responding to. For example, `@method POST` or `@method GET` will tell the server that the HTTP method is GET or POST\r\n 3. Add @methodUri value for the method URI. \r\n    * `@methodUri /` - you can either just add the \"/\" or omit the annotation \r\n    * `@methodUri /list` - hard coded example\r\n    * `@methodUri /user/([0-9]+)` - regex example - always add the '()' around the regex\r\n    Note that the full URI for your resource is a combination of the server base URI, that was set during \\restlt\\Server initialization and the addition of @resourceBaseUri + @methodUri. In general consider the URI as of a regular expression. This is how it is evaluated and followint the preg_match() rules for binding its third parameter, whatever you surround with \"()\" ends up as a parameter of your method.\r\n\r\nFor example, if your complete URI ends up to be /account/([0-9]+)/contact/([a-z]+), your method should be accepting 2 parameters. The first of which will be a sequence of digits and the second one letters.\r\n \r\nA resource can have multiple methods that respond to GET, POST, etc.\r\n \r\n###A simple resource example\r\n```php\r\nnamespace restlt\\examples\\resources;\r\n/**\r\n * \r\n * @resourceBaseUri /resource1\r\n */\r\nclass Resource1 extends \\restlt\\Resource {\r\n    \r\n    /**\r\n     * Note that the regex in \"()\" gets converted to a parameter of the method\r\n     * Since v 1.1.0a this user comment section will appear in a simple HTML format\r\n     * accesible at the root of ther server like this: http://url.com/approot.html\r\n     * @method GET\r\n     * @methodUri /([0-9]+)\r\n     */\r\n    public function getMe($id = '') {\r\n        $obj = new \\stdClass ();\r\n        $obj->a = array (9,8,7);\r\n        //obtain the \"someParam\" - from POST or GET\r\n        $this->get ( 'someParam',$defaultValueIfParamIsMissing );\r\n        return $boj;\r\n    }\r\n    /**\r\n     *\r\n     * @method PUT\r\n     * @methodUri /save\r\n     */\r\n    public function putMe() {\r\n        //fetch the parameters from the query string\r\n        $params = $this->request->getQueryParams ();\r\n        $params = $this->request->getPostParams ();\r\n        \r\n        //get the raw data\r\n        $postPayload= $this->request->getRawPost ();\r\n            ......\r\n        //return whatever you want\r\n        return $res;\r\n    }\r\n}\r\n```\r\n For the just coded resource we have created two methods, `Resource1::getMe()` and `Resource1::putMe()`. There is no naming convention for the methods. The names are chosen for better clarity. The method Resource1::get() we will be responding to the 'GET' http method and the URI that will access it is /resource1/123 or any number as per the regex. The latter URI will be prepended with the Server base URI. You set the Server base URI when instantiating the \\restlt\\Server.\r\n\r\nSimilar to the 'GET' we have built the 'PUT' method  `Resource1::putMy()`. When the server receives a 'PUT'  request and the URI is /resource1/save the  `Resource1::putMe()` method will respond with whatever you decide to return.\r\nThe methods must return data in order for you to receive it as a XML or JSON formatted string at the client.\r\nThe JSON or XML conversion happens automatically. More on adding your own twist to the output will be discussed in the advanced section.\r\n \r\n### Accessing the GET, POST and raw data within the resources' methods.\r\n```php\r\n//accessing GET\r\n        $params = $this->request->getQueryParams ();\r\n//accessing POST\r\n        $params = $this->request->getPostParams ();\r\n```   \r\nGet the raw data as it was submited in the body\r\n```php\r\n        $postPayload= $this->request->getRawPost (); \r\n```\r\nGet one parameter at a time\r\n```php\r\n        $this->get($paramName);\r\n```\r\nObtain the parameter ($_REQUEST) and at the same time provide a default value. This helps you avoid the checks for set or empty values\r\n```php\r\n        $this->get('page',1);\r\n```\r\n###Public API documentation\r\nIf you added User comments to the API resource methods, now you can access them by going to the root of the server.\r\n`http://myserveurl.com/serverroot.html`\r\nWhere the `serverroot` is the base URI you have defined when initializing the \\restlt\\Server object.\r\n\r\n##Handling errors\r\n###Exceptions\r\nAll exceptions thrown by the server will end up as 404 or 500 errors.\r\nIf you throw your own error the result code will be 500, but you have the controll of what gets thrown or caught. \r\nThe message resulting from the latter will be sent to the server in the error object as part of the result.\r\nFor example if you throw `throw new \\Exception('My Error',1000);` you will get the follwing in the response body.\r\nThe HTTP status code however will be 500.\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<result>\r\n  <errors>\r\n    <error>\r\n      <error>\r\n        <message>My Error</message>\r\n        <code>1000</code>\r\n      </error>\r\n    </error>\r\n  </errors>\r\n</result>\r\n```\r\n###PHP/user errors\r\nErrors caused by  E_ERROR, E_USER_ERROR, E_WARNING, E_USER_WARNING, E_CORE_ERROR, E_CORE_WARNING, E_DEPRECATED and E_STRICT will end up as 500. You can see this error in the php error log.  \r\n## Some advanced usage\r\n### Event Hooks\r\nLet's say you need to add some twist to the execution flow or put some checks, logging or whatever comes to mind. There are three event hooks that provide a way to do that. The callbacks provided to these event hooks need to be Callable. The method or function signatures are provided bellow.\r\n\r\n### On Before event - * before the flow enters your resource method. *\r\n\r\n```php\r\nclass Resource1 extends \\restlt\\Resource {\r\n    public function __construct() {\r\n        $f1 = function ($r) {\r\n             //do something\r\n        };\r\n        $this->on ( Resource::ON_BEFORE, 'myFunctionName', $f1 );\r\n    }\r\n```\r\nor instead of a closure, pass a Callable\r\n```php\r\n    $this->on ( Resource::ON_BEFORE, 'myFunctionName', array($obj,$method) );\r\n    }\r\n```\r\nThe callback function provided for this event has the following signature\r\n```php\r\n    /**\r\n     * @param \\restlt\\Request $r \r\n     * @return void\r\n     * /\r\n    $f = function (\\restlt\\Request $r){};\r\n```\r\n### On After event - * after the resource function returns *\r\n```php\r\n$this->on ( Resource::ON_AFTER, 'myFunctionName', array($obj,$method) );\r\n```\r\n    * The callback function provided for this event has the following signature *\r\n```php\r\n    /**\r\n     * @param \\restlt\\Request $request \r\n     * @param \\restlt\\Response $response\r\n     * @param mixed $return the result of your resource method\r\n     * @return void\r\n     * /\r\n    $f = function (\\restlt\\Request $request, \\restlt\\Response $response, $return){};\r\n```\r\n### On error - * when an error occurs inside the method *\r\nIf you throw an exception within a method it will get eventually caught in the top layer and you'll get 500. This event actually is triggered when E_ERROR,E_USER_ERROR,E_WARNING,E_USER_WARNING,E_CORE_ERROR,E_CORE_WARNING,E_DEPRECATED,E_STRICT are thrown.\r\n```php\r\n    $this->on ( Resource::ON_ERROR, 'myFunctionName', array($obj,$method) );\r\n```\r\nFollows the callback function signature\r\n```php\r\n/**\r\n* @param \\restlt\\Request $r \r\n* @param \\restlt\\Response $r\r\n* @return \\Exception $exception - the result of your resource method\r\n* @return void\r\n* /\r\n$f = function (\\restlt\\Request $request, \\restlt\\Response $response,\\Exception $exception){};\r\n```\r\n## register event examples: \r\n### Register ON_BEFORE event hook for a specific resource method\r\n```php\r\n        $f1 = function ($r) {\r\n        //do something\r\n        };\r\n        //the context here is the Resource, hence $this\r\n        $this->on (\\restlt\\Resource::ON_BEFORE, 'getMe', $f1 );\r\n```\r\n### Register ON_BEFORE event hook for ANY resource method\r\n```php\r\n        $f1 = function ($r) {\r\n        //do something\r\n        };\r\n        //the context here is the Resource, hence $this\r\n        $this->on (\\restlt\\Resource::ON_BEFORE, NULL, $f1 );\r\n```\r\n## Adding some cache\r\nSince the addition of a great amound of resources could cost us in performance, RestLt uses some caching to aleviate this issue.\r\nIn it's most basic implementation the server supports natively Memcached extention. However there are ways to add third party caching systems that are already supporting multitude of backend cache adapters.\r\nIn order to use any of the two third party implementations supported by RestLt you shuld install them via [Composer](getcomposer.org).\r\nWhen installing RestLt via [Composer](getcomposer.org) you should have seen suggestions for either one of those.\r\n### Using built in Memcached implementation\r\n```php\r\n    $memcached = new Memcached ();\r\n    $memcached->addServer ( 'localhost', 11211 );\r\n    $s = new Server ( '/' );\r\n    $s->setCacheAdapter ( new \\restlt\\cache\\RestltMemcachedAdapter( $memcached ) );\r\n    $s->serve ();\r\n```\r\n### Using Zend Cache component - [Zend Cache] (http://framework.zend.com/manual/2.0/en/modules/zend.cache.storage.adapter.html)\r\nIf you are already using ZF2 caching component there is an easy way to add it to RestLt.\r\nHere assuming that you know how to use `Zend\\Cache\\StorageFactory::adapterFactory` you need to obtain a\r\nStorageAdapter. \r\n```php\r\n    $zendCache = Zend\\Cache\\StorageFactory::adapterFactory('apc',$options);\r\n    $s->setCacheAdapter ( new \\restlt\\cache\\ZFCacheAdapter ( $zendCache ) );\r\n```\r\n\r\n### Using Doctrine's cache implementation - [Doctrine Cache](http://docs.doctrine-project.org/en/latest/reference/caching.html)\r\n    Here you should know how to obtain a Doctrine CacheProvider.\r\n```php\r\n    $memcache = new Memcache();\r\n    $memcache->connect('memcache_host', 11211);\r\n    $doctrineCacheProvider = new \\Doctrine\\Common\\Cache\\MemcacheCache();\r\n    $doctrineCacheProvider->setMemcache($memcache);\r\n    $s->setCacheAdapter ( new \\restlt\\cache\\DoctrineCacheAdapter($doctrineCacheProvider) );\r\n```\r\n### Addig your favorite cache implementation\r\nIf you don't use any of the formerly mentioned cache implementations by Zend or Doctrine you can add your own.\r\nIn order for us to be able to use a third party Cache library we need to create a class that implements `restlt\\cache\\CacheAdapterInterface`\r\n```php\r\nclass OtherframeworkCacheAdapter implements CacheAdapterInterface {\r\n        public function __construct($cacheInstance = null) {\r\n                // \r\n        }\r\n        public function test($key) {\r\n                //\r\n        }\r\n\r\n        public function set($key, $item) {\r\n                //\r\n        }\r\n\r\n        public function get($key) {\r\n                //\r\n        }\r\n}\r\n```\r\nNow you have to tell the server to use it in your bootsrap routine.\r\n```php\r\n$s->setCacheAdapter ( new \\restlt\\cache\\OtherfameworkCacheAdapter($otherframeworkInstance) );\r\n```\r\n\r\n##Adding your own annotations to the Resource methods or the Resource classes\r\nIf you need to lock some data needed for processing during request execution you can add a custom annotation to your methods.\r\nHere is an example how to you could use that feature.\r\n```php\r\n/**\r\n * @method POST\r\n * @baseUri /save\r\n * @allowedRoles admin, mega-admin\r\n */\r\n public function saveUser(){\r\n     $roles = $this->annotations->get('allowedRoles');\r\n     //do something here with the data. $roles now has the string 'admin, mega-admin'\r\n     return $something;\r\n }\r\n```\r\n## In need for custom output?\r\nOut of the box RestLt comes with json and xml output strategies. \r\nLet's say you need to provide some home grown obfuscated or even encrypted reponse. \r\nFor whatever the reason is, you might want to do that one day.\r\nIt could be that you want to communicate with the client via some specific protocol and want to wrap the data in it. \r\nOr may be want to change the current ones. Here is how.\r\n###Adding a custom response of your own.\r\nFirst we need to create a class that implements the `\\restlt\\output\\TypeConversionStrategyInterface`. Let's start.\r\n```php\r\nnamespace my\\name\\space;\r\nclass SerializeOutputStrategy implements \\restlt\\output\\TypeConversionStrategyInterface {\r\n    /**\r\n     * @see \\restlt\\output\\TypeConversionStrategyInterface::execute()\r\n     */\r\n    public function execute(\\restlt\\Result $data) {\r\n        return serialize($data);\r\n    }\r\n}\r\n```\r\n\r\nThat's it. We have implemented a serializer sutput strategy for our RestLt server.\r\nNext on the list to make this work is to tell the server about it.\r\n```php\r\n$s->getResponse()->addResponseOutputStrategies('sphp', '\\my\\name\\space\\SerializeOutputStrategy');\r\n```\r\nWhat we did here is the follwoing. We let the server know that if we encounter '.sphp' extension in our URL we will respond with the associated output, in this case `SerializeOutputStrategy`.\r\nNow all of your request ( GET, POST, PUT, PATCH ...) with URLs such like:\r\n * `http://example.com/my/path/123.sphp` \r\n * `http://example.com/my/path.sphp?q=stuff` \r\n \r\netc. will respond with serialized data accoring to your new output strategy.\r\n\r\n###Extending the currently available `\\restlt\\output\\XmlTypeConverter` and `\\restlt\\output\\JsonTypeConverter`.\r\nTo modify the behaviour of the current JSON or XMl converters, you will need to extend them. There is not much to remember here. Extending the class is nothing different than what you do with any other class you do extend.\r\nHowever you need to register your new class with the server and associate it with the XML or JSON types.\r\n```php\r\n$s->getResponse()->addResponseOutputStrategies('xml', '\\my\\name\\space\\MyXmlStrategy');\r\n```\r\nNow all requests of the kind `http://example.com/my/path.xml?q=stuff` will be processed by your new class.\r\nAlso,client requests that are made with 'Content-type:application/xml' will be processed by it too. \r\nthe same goes if you decide to extend the json converter.\r\n\r\n\r\n##Doc block Meta reference\r\n\r\n|Annotation          |   Where    |  Required | Values |\r\n|--------------------|:----------:|----------:|--------|\r\n|  @resourceBaseUri  | CLASS      | YES       | string |\r\n|  @baseUri          | METHDO     | NO        | string/regex or empty |\r\n| @cacheControlMaxAge| METHOD     | NO        | integer| \r\n| @method            | METHOD     | YES       | GET, POST, PUT, PATCH, DELETE |\r\n \r\n\r\n### Resource class doc block\r\n    @resourceBaseUri -> specifies the resource base URI relative to the Server base URI\r\n### Resource method doc block\r\n    @method -> specifies what HTTP method this resource method respnds to. POST, GET, PUT, PATCH, DELETE are allowed\r\n    @methodBaseUri -> URI relative to the resource base uri value specified in the @resourceBaseUri\r\n    @cacheControlMaxAge -> this value directly affects the 'Cache-Control max-age' HTTP header value and has nothing to do with the local caching feature  \r\n## Logging \r\nAs of version 1.2.0-alpha there is a way to add a logger.\r\nAdded was [PSR-3](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md) compatible logger. However a native logger implementation is not and probably will not be added.\r\nYou will need to inject your logger which should implement Psr\\Log\\LoggerInterface .\r\n\r\n```\r\n$server->setLog($yourcustomLogger);\r\n```\r\nAn adapter for the Zend Logger will be added when this version is released.\r\n\r\n## Misc. usage tricks    \r\n### Forcing the server to respond always with spcified reponse type regardles of the request `Content-type`\r\nThe default behavior is specified by the Accept header. If the 'Accept' is plain/text or anything that does not refer to SML of JSON the\r\ndefault response will be returned in JSON.\r\n1. Force response type for all Resources registered with the server to respond with XML or JSON\r\n```php\r\n$s = new \\restlt\\Server('base/uri');\r\n$s->getResponse()->setForceResponseType(Response::APPLICATION_JSON);\r\n```\r\n\r\n2. Forcing a method to always respond with XML or JSON.\r\n```php\r\n/**\r\n * @resourceBaseUri /entity\r\n */\r\nclass myResource extends \\restlt\\Resource\r\n/**\r\n * @methodUri /submit\r\n * @method POST\r\n */\r\npublic function myMethod(){\r\n    $this->getResponse()->setForceResponseType(\\restlt\\Response::APPLICATION_XML);\r\n    #some code here ...\r\n    return $result;\r\n}\r\n```\r\n3. Non-coding trick to force desired response\r\n    When creating the URL for the client simply append to the end of the URI (not the  query part) .json or .xml\r\n    * 'GET' request - http://example.com/user/list.json?p=1&q=sam\r\n    * 'POST' request - http://example.com/user.json\r\n    * 'GET' request - http://example.com/user/103.xml - get user resource with XML. not te integer 103 will be preserved as part of the URI and will be passed along to your method if it was defined as a regex in the meta for the resource method\r\n","google":"UA-45407810-1","note":"Don't delete this file! It's used internally to help with page regeneration."}